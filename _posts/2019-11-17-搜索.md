---
layout:     post
title:      搜索
subtitle:   搜索~ 
date:       2019-11-17
author:     Alpha
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - 数据结构与算法
---



### 宽度有先搜索（BFS）

**leetcode279 完全平方数**

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

**示例 1:**

```
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
```

**示例 2:**

```
输入: n = 13
输出: 2
解释: 13 = 4 + 9.
```

>**分析：**
>用一个数组来记录已有的结果，初始化为正无穷，外层循环变量``i``从``0``到``n``，内层循环变量``j``在``i``的基础上依次加上每个数的平方，那么``i + j * j ``这个数需要的最少的完全平方数的数量就是数组中当前的数值和``i``位置的数组``+1``这两者中的较小值

**C++实现：**

```C++
class Solution {
public:
	int numSquares(int n) {
		vector<int> dp(n + 1, INT_MAX);
		dp[0] = 0;
		for (int i = 0; i <= n; i++){
			for (int j = 1; i + j*j <= n; j++){
				dp[i + j*j] = min(dp[i + j*j], dp[i] + 1);
			}
		}
		return dp[n];
	}
};
```



### 深度优先搜索（DFS）

**leetcode695 岛屿的最大面积**

给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)

**示例 1:**

```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```

对于上面这个给定矩阵应返回 `6`。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。



**示例 2:**

```
[[0,0,0,0,0,0,0,0]]
```

对于上面这个给定的矩阵, 返回 `0`。

**注意:** 给定的矩阵`grid` 的长度和宽度都不超过 50。



>分析：本题主要复习的是图的DFS。
>
>首先如何用递归去完成DFS呢？思路是这样的，首先找到目标点，然后从目标点发散开来。
>
>怎么发散？那就要有一个方向。没错，那我们需要实现方向，怎么实现？数组增减1咯，在后面的样例中我们用一个数组来表示方向。
>
>然后当我们到达新的方向之后怎么办？继续DFS，没错。怎么实现？那就是递归咯。
>
>等等，每次到达新的地方都要DFS么？当然不是，如果那个值是你要找的，那你就继续扩散，如果不是你要找的，那就不扩散啊。怎么实现？加一条if语句咯。
>
>再等等，你是不是没有考虑数组越界？没错，那我们还需要一些判断语句，保证我们的数组是不越界的。
>
>好的，dfs的所有思路讲解完毕。
>
>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。
>
>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)



**C++实现：**