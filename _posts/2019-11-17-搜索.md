---
layout:     post
title:      搜索
subtitle:   搜索~ 
date:       2019-11-17
author:     Alpha
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - 数据结构与算法
---



### 宽度有先搜索（BFS）

**leetcode279 完全平方数**

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

**示例 1:**

```
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
```

**示例 2:**

```
输入: n = 13
输出: 2
解释: 13 = 4 + 9.
```

>**分析：**
>用一个数组来记录已有的结果，初始化为正无穷，外层循环变量``i``从``0``到``n``，内层循环变量``j``在``i``的基础上依次加上每个数的平方，那么``i + j * j ``这个数需要的最少的完全平方数的数量就是数组中当前的数值和``i``位置的数组``+1``这两者中的较小值

**C++实现：**

```C++
class Solution {
public:
	int numSquares(int n) {
		vector<int> dp(n + 1, INT_MAX);
		dp[0] = 0;
		for (int i = 0; i <= n; i++){
			for (int j = 1; i + j*j <= n; j++){
				dp[i + j*j] = min(dp[i + j*j], dp[i] + 1);
			}
		}
		return dp[n];
	}
};
```



### 深度优先搜索（DFS）

**leetcode695 岛屿的最大面积**

给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)

**示例 1:**

```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```

对于上面这个给定矩阵应返回 `6`。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。